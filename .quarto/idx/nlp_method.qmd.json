{"title":"NLP Methods","markdown":{"yaml":{"title":"NLP Methods","subtitle":"NLP Analysis: Extracting Required Skills from Job Postings","author":[{"name":"Shreya Mani","affiliations":[{"id":"bu","name":"Boston University","city":"Boston","state":"MA"}]}],"format":{"html":{"toc":true,"number-sections":true,"df-print":"paged"}}},"headingText":"Introduction","containsRefs":false,"markdown":"\n\nIn this project, we used Natural Language Processing (NLP) to extract required skills from job postings based on their description text in the BODY column. The dataset contains job postings with unstructured text descriptions, which often mention skills needed for the role (e.g., \"analyze data\" or \"develop software\"). Our goal was to identify and analyze the most common skills mentioned in these postings, providing insights into the skills most in demand. This analysis can help job seekers understand the key skills to develop and assist employers in identifying trends in skill requirements.\n\n# Data Preprocessing\nWe started by loading the dataset and focusing on the BODY column, which contains the job description text. The BODY text is unstructured and requires preprocessing for NLP analysis. We performed the following steps:\n\nTokenization and Cleaning: Converted the text to lowercase, removed punctuation, and tokenized the text into words.\n\n\nStop Word Removal: Removed common stop words (e.g., \"the\", \"is\") that don’t add meaningful information. We used a predefined list of common stop words to avoid external dependencies.\n\n\nSkill Extraction: Defined a list of common skills relevant to job postings (e.g., \"data analysis,\" \"software development\") and searched for these skills in the cleaned text. For simplicity, we used keyword matching to identify skills, but this could be extended with more advanced NLP techniques like named entity recognition (NER) or pre-trained models.\n\nSince this task is exploratory and doesn’t require a target variable, we didn’t split the data into training and testing sets. Instead, we processed all available job descriptions to extract and analyze skills.\n\nHere’s the Python code we used for data preprocessing and skill extraction:\n```{python}\n#| label: skill-extraction\n#| echo: true\n#| warning: false\n#| message: false\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport os\nimport re\nfrom collections import Counter\n\n# Load dataset\ncsv_path = 'region_analysis/lightcast_job_postings.csv'\ndf = pd.read_csv(csv_path)\n\n# Drop rows with missing job descriptions\ndf = df.dropna(subset=['BODY'])\n\n# Define stop words\nstop_words = {\n    'a', 'an', 'and', 'are', 'as', 'at', 'be', 'by', 'for', 'from', 'has', 'he',\n    'in', 'is', 'it', 'its', 'of', 'on', 'that', 'the', 'to', 'was', 'were', 'will',\n    'with', 'i', 'me', 'my', 'myself', 'we', 'our', 'ours', 'ourselves', 'you', 'your',\n    'yours', 'yourself', 'yourselves', 'him', 'his', 'her', 'hers', 'herself', 'it',\n    'its', 'itself', 'they', 'them', 'their', 'theirs', 'themselves', 'what', 'which',\n    'who', 'whom', 'this', 'that', 'these', 'those', 'am', 'is', 'are', 'was', 'were',\n    'be', 'been', 'being', 'have', 'has', 'had', 'having', 'do', 'does', 'did', 'doing',\n    'a', 'an', 'the', 'and', 'but', 'if', 'or', 'because', 'as', 'until', 'while', 'of',\n    'at', 'by', 'for', 'with', 'about', 'against', 'between', 'into', 'through', 'during',\n    'before', 'after', 'above', 'below', 'to', 'from', 'up', 'down', 'in', 'out', 'on',\n    'off', 'over', 'under', 'again', 'further', 'then', 'once', 'here', 'there', 'when',\n    'where', 'why', 'how', 'all', 'any', 'both', 'each', 'few', 'more', 'most', 'other',\n    'some', 'such', 'no', 'nor', 'not', 'only', 'own', 'same', 'so', 'than', 'too', 'very',\n    's', 't', 'can', 'will', 'just', 'don', 'should', 'now'\n}\n\n# Clean text\ndef clean_text(text):\n    text = text.lower()\n    text = re.sub(r'[^a-z\\s]', '', text)\n    tokens = text.split()\n    return ' '.join([word for word in tokens if word not in stop_words])\n\ndf['BODY_CLEANED'] = df['BODY'].apply(clean_text)\n\n# Define common skills\nskills_list = [\n    \"data analysis\", \"software development\", \"machine learning\",\n    \"project management\", \"communication\", \"teamwork\",\n    \"sql\", \"python\", \"modeling\", \"analytics\"\n]\n\n# Extract skills\ndef extract_skills(text):\n    found_skills = []\n    for skill in skills_list:\n        if skill in text:\n            found_skills.append(skill)\n    return found_skills\n\ndf['SKILLS'] = df['BODY_CLEANED'].apply(extract_skills)\n\n# Flatten skill list and count\nall_skills = [skill for sublist in df['SKILLS'] for skill in sublist]\nskill_counts = Counter(all_skills)\n\n\n\n# Visualize top skills\nplt.figure(figsize=(10, 6))\nif skill_counts:\n    skills, counts = zip(*sorted(skill_counts.items(), key=lambda x: x[1], reverse=True))\n    plt.bar(skills, counts, color='skyblue')\n    plt.xlabel('Skills')\n    plt.ylabel('Frequency')\n    plt.title('Most Common Skills in Job Postings')\n    plt.xticks(rotation=45, ha='right')\n    plt.tight_layout()\n    plt.savefig('skills_frequency.png')\n    plt.show()\nelse:\n    print(\"No skills were found in the job descriptions.\")\n```\n# Skill Analysis and Visualization\n\nAfter extracting skills from the job descriptions, we analyzed their frequency to identify the most common skills mentioned. We visualized the results using a bar plot, showing the count of each skill across all job postings. This helps highlight the skills that are most in demand based on the dataset.\n\nHere’s the code we used for analyzing and visualizing the skills:\n```{python}\n# Plot the most common skills\nplt.figure(figsize=(10, 6))\nskills, counts = zip(*skill_counts.items()) if skill_counts else ([], [])\nif counts:  # Ensure there are skills to plot\n    plt.bar(skills, counts, color='skyblue')\n    plt.xlabel('Skills')\n    plt.ylabel('Frequency')\n    plt.title('Most Common Skills in Job Postings')\n    plt.xticks(rotation=45, ha='right')\n    plt.tight_layout()\n    plt.savefig('skills_frequency.png')\nelse:\n    print(\"No skills were found in the job descriptions.\")\n```","srcMarkdownNoYaml":"\n\n# Introduction\nIn this project, we used Natural Language Processing (NLP) to extract required skills from job postings based on their description text in the BODY column. The dataset contains job postings with unstructured text descriptions, which often mention skills needed for the role (e.g., \"analyze data\" or \"develop software\"). Our goal was to identify and analyze the most common skills mentioned in these postings, providing insights into the skills most in demand. This analysis can help job seekers understand the key skills to develop and assist employers in identifying trends in skill requirements.\n\n# Data Preprocessing\nWe started by loading the dataset and focusing on the BODY column, which contains the job description text. The BODY text is unstructured and requires preprocessing for NLP analysis. We performed the following steps:\n\nTokenization and Cleaning: Converted the text to lowercase, removed punctuation, and tokenized the text into words.\n\n\nStop Word Removal: Removed common stop words (e.g., \"the\", \"is\") that don’t add meaningful information. We used a predefined list of common stop words to avoid external dependencies.\n\n\nSkill Extraction: Defined a list of common skills relevant to job postings (e.g., \"data analysis,\" \"software development\") and searched for these skills in the cleaned text. For simplicity, we used keyword matching to identify skills, but this could be extended with more advanced NLP techniques like named entity recognition (NER) or pre-trained models.\n\nSince this task is exploratory and doesn’t require a target variable, we didn’t split the data into training and testing sets. Instead, we processed all available job descriptions to extract and analyze skills.\n\nHere’s the Python code we used for data preprocessing and skill extraction:\n```{python}\n#| label: skill-extraction\n#| echo: true\n#| warning: false\n#| message: false\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport os\nimport re\nfrom collections import Counter\n\n# Load dataset\ncsv_path = 'region_analysis/lightcast_job_postings.csv'\ndf = pd.read_csv(csv_path)\n\n# Drop rows with missing job descriptions\ndf = df.dropna(subset=['BODY'])\n\n# Define stop words\nstop_words = {\n    'a', 'an', 'and', 'are', 'as', 'at', 'be', 'by', 'for', 'from', 'has', 'he',\n    'in', 'is', 'it', 'its', 'of', 'on', 'that', 'the', 'to', 'was', 'were', 'will',\n    'with', 'i', 'me', 'my', 'myself', 'we', 'our', 'ours', 'ourselves', 'you', 'your',\n    'yours', 'yourself', 'yourselves', 'him', 'his', 'her', 'hers', 'herself', 'it',\n    'its', 'itself', 'they', 'them', 'their', 'theirs', 'themselves', 'what', 'which',\n    'who', 'whom', 'this', 'that', 'these', 'those', 'am', 'is', 'are', 'was', 'were',\n    'be', 'been', 'being', 'have', 'has', 'had', 'having', 'do', 'does', 'did', 'doing',\n    'a', 'an', 'the', 'and', 'but', 'if', 'or', 'because', 'as', 'until', 'while', 'of',\n    'at', 'by', 'for', 'with', 'about', 'against', 'between', 'into', 'through', 'during',\n    'before', 'after', 'above', 'below', 'to', 'from', 'up', 'down', 'in', 'out', 'on',\n    'off', 'over', 'under', 'again', 'further', 'then', 'once', 'here', 'there', 'when',\n    'where', 'why', 'how', 'all', 'any', 'both', 'each', 'few', 'more', 'most', 'other',\n    'some', 'such', 'no', 'nor', 'not', 'only', 'own', 'same', 'so', 'than', 'too', 'very',\n    's', 't', 'can', 'will', 'just', 'don', 'should', 'now'\n}\n\n# Clean text\ndef clean_text(text):\n    text = text.lower()\n    text = re.sub(r'[^a-z\\s]', '', text)\n    tokens = text.split()\n    return ' '.join([word for word in tokens if word not in stop_words])\n\ndf['BODY_CLEANED'] = df['BODY'].apply(clean_text)\n\n# Define common skills\nskills_list = [\n    \"data analysis\", \"software development\", \"machine learning\",\n    \"project management\", \"communication\", \"teamwork\",\n    \"sql\", \"python\", \"modeling\", \"analytics\"\n]\n\n# Extract skills\ndef extract_skills(text):\n    found_skills = []\n    for skill in skills_list:\n        if skill in text:\n            found_skills.append(skill)\n    return found_skills\n\ndf['SKILLS'] = df['BODY_CLEANED'].apply(extract_skills)\n\n# Flatten skill list and count\nall_skills = [skill for sublist in df['SKILLS'] for skill in sublist]\nskill_counts = Counter(all_skills)\n\n\n\n# Visualize top skills\nplt.figure(figsize=(10, 6))\nif skill_counts:\n    skills, counts = zip(*sorted(skill_counts.items(), key=lambda x: x[1], reverse=True))\n    plt.bar(skills, counts, color='skyblue')\n    plt.xlabel('Skills')\n    plt.ylabel('Frequency')\n    plt.title('Most Common Skills in Job Postings')\n    plt.xticks(rotation=45, ha='right')\n    plt.tight_layout()\n    plt.savefig('skills_frequency.png')\n    plt.show()\nelse:\n    print(\"No skills were found in the job descriptions.\")\n```\n# Skill Analysis and Visualization\n\nAfter extracting skills from the job descriptions, we analyzed their frequency to identify the most common skills mentioned. We visualized the results using a bar plot, showing the count of each skill across all job postings. This helps highlight the skills that are most in demand based on the dataset.\n\nHere’s the code we used for analyzing and visualizing the skills:\n```{python}\n# Plot the most common skills\nplt.figure(figsize=(10, 6))\nskills, counts = zip(*skill_counts.items()) if skill_counts else ([], [])\nif counts:  # Ensure there are skills to plot\n    plt.bar(skills, counts, color='skyblue')\n    plt.xlabel('Skills')\n    plt.ylabel('Frequency')\n    plt.title('Most Common Skills in Job Postings')\n    plt.xticks(rotation=45, ha='right')\n    plt.tight_layout()\n    plt.savefig('skills_frequency.png')\nelse:\n    print(\"No skills were found in the job descriptions.\")\n```"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"css":["styles.css"],"number-sections":true,"output-file":"nlp_method.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.40","theme":"cosmo","title":"NLP Methods","subtitle":"NLP Analysis: Extracting Required Skills from Job Postings","author":[{"name":"Shreya Mani","affiliations":[{"id":"bu","name":"Boston University","city":"Boston","state":"MA"}]}]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}