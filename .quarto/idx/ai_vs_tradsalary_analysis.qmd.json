{"title":"<!--","markdown":{"headingText":"<!--","containsRefs":false,"markdown":"title: \"AI vs Traditional Salary Analysis\"\nsubtitle: \"Salary & Compensation Trends - Job Market Analysis 2024\"\nauthor:\n  - name: Group 10\n    affiliations:\n      - id: bu\n        name: Boston University\n        city: Boston\n        state: MA\nformat: \n  html:\n    toc: true\n    number-sections: true\n    df-print: paged\n---\n-->\n\n```{python}\nimport pandas as pd\n\n# Load cleaned dataset (update path)\ndf = pd.read_csv('region_analysis/lightcast_job_postings.csv')\n\n# Convert SALARY to numeric and drop nulls\ndf['SALARY'] = pd.to_numeric(df['SALARY'], errors='coerce')\ndf = df.dropna(subset=['SALARY'])\n\n# Tag AI vs Non-AI jobs\ndef tag_ai(row):\n    title = str(row['TITLE_NAME']).lower()\n    industry = str(row['NAICS_2022_2_NAME']).lower()\n    \n    if ('ai' in title or 'artificial intelligence' in title or 'machine learning' in title or\n        'data scientist' in title or 'deep learning' in title or 'nlp' in title or 'ml' in title or\n        'data engineer' in title or 'ml engineer' in title or 'scientist' in title or\n        'computer vision' in title or 'robotics' in title or\n        'professional, scientific, and technical services' in industry or 'information' in industry):\n        return 'AI Career'\n    else:\n        return 'Non-AI Career'\n\ndf['Career_Type'] = df.apply(tag_ai, axis=1)\nprint(df['Career_Type'].value_counts())\n\n# Group by STATE and Career Type → Avg Salary\nstate_salary = df.groupby(['STATE_NAME', 'Career_Type'])['SALARY'].mean().round(2).reset_index()\nstate_salary = state_salary.sort_values(by='SALARY', ascending=False)\n\n# Show top 5 for each category\nprint(\"Top 5 States for AI Careers:\")\nprint(state_salary[state_salary['Career_Type'] == 'AI Career'].head(5))\n\nprint(\"\\nTop 5 States for Non-AI Careers:\")\nprint(state_salary[state_salary['Career_Type'] == 'Non-AI Career'].head(5))\n\n# Optional: save to CSV\n# state_salary.to_csv('statewise_ai_vs_nonai_salary.csv', index=False)\n```\n\n```{python}\nimport matplotlib.pyplot as plt\n\n# Top 5 AI states\ntop_ai = state_salary[state_salary['Career_Type'] == 'AI Career'].head(5)\n\n# Top 5 Non-AI states\ntop_nonai = state_salary[state_salary['Career_Type'] == 'Non-AI Career'].head(5)\n\n# Plot AI Career Salaries\nplt.figure(figsize=(8, 5))\nplt.barh(top_ai['STATE_NAME'], top_ai['SALARY'])\nplt.xlabel(\"Average Salary ($)\")\nplt.title(\"Top 5 States for AI Careers\")\nplt.gca().invert_yaxis()\nplt.tight_layout()\nplt.savefig(\"top_ai_states.png\")\nplt.show()\n\n# Plot Non-AI Career Salaries\nplt.figure(figsize=(8, 5))\nplt.barh(top_nonai['STATE_NAME'], top_nonai['SALARY'], color='orange')\nplt.xlabel(\"Average Salary ($)\")\nplt.title(\"Top 5 States for Non-AI Careers\")\nplt.gca().invert_yaxis()\nplt.tight_layout()\nplt.savefig(\"top_nonai_states.png\")\nplt.show()\n```\n\n```{python}\n# Count of jobs used to compute avg salary\nstate_counts = df.groupby(['STATE_NAME', 'Career_Type'])['SALARY'].agg(['mean', 'count']).round(2).reset_index()\nstate_counts = state_counts.sort_values(by='mean', ascending=False)\n\n# Show top 10 AI states by average salary + count\nprint(state_counts[state_counts['Career_Type'] == 'AI Career'].head(10))\n```\n\n```{python}\nall_ai_states = state_counts[state_counts['Career_Type'] == 'AI Career']\nprint(all_ai_states['STATE_NAME'].unique())\n```\n\n```{python}\nreliable_ai_states = state_counts[\n    (state_counts['Career_Type'] == 'AI Career') &\n    (state_counts['count'] >= 50)\n].sort_values(by='mean', ascending=False)\n\nprint(reliable_ai_states.head(10))\n```\n\n```{python}\nbig_states = ['Massachusetts', 'New York', 'New Jersey', 'California', 'Texas']\n\nai_counts_big_states = df[\n    (df['Career_Type'] == 'AI Career') & \n    (df['STATE_NAME'].isin(big_states))\n].groupby('STATE_NAME')['SALARY'].agg(['count', 'mean']).round(2).sort_values(by='count', ascending=False)\n\nai_counts_big_states.rename(columns={'count': 'AI Job Postings', 'mean': 'Avg Salary ($)'}, inplace=True)\n\nprint(ai_counts_big_states)\n```\n\n```{python}\nai_median_salary = df[df['Career_Type'] == 'AI Career'].groupby('STATE_NAME')['SALARY'].median().round(2).reset_index()\nai_counts = df[df['Career_Type'] == 'AI Career'].groupby('STATE_NAME')['SALARY'].count().reset_index(name='Job_Count')\n\n# Merge them\nai_summary = pd.merge(ai_median_salary, ai_counts, on='STATE_NAME')\nai_summary.columns = ['State', 'Median Salary ($)', 'AI Job Count']\n\n# Optional: Filter for states with decent sample size\nai_summary = ai_summary[ai_summary['AI Job Count'] >= 50]\n\n# Sort by Median Salary\nai_summary = ai_summary.sort_values(by='Median Salary ($)', ascending=False)\n\nprint(ai_summary.head(10))\n```\n\n```{python}\nimport matplotlib.pyplot as plt\n\ntop_states = ai_summary.head(10)\n\nplt.figure(figsize=(10, 6))\nplt.barh(top_states['State'], top_states['Median Salary ($)'], color='teal')\nplt.xlabel(\"Median Salary ($)\")\nplt.title(\"Top 10 States for AI Careers (Median Salary, ≥50 Jobs)\")\nplt.gca().invert_yaxis()\nplt.tight_layout()\nplt.savefig(\"top_ai_states_median.png\")\nplt.show()\n```\n\n\n## Urban vs Rural States – Median AI Salary Comparison\n\nThis chart compares the median salaries of AI careers in selected **urban** (California, New York, Massachusetts) and **rural** (Arkansas, Montana, Nebraska) states. It highlights how urban hubs tend to offer significantly higher AI-related salaries, reinforcing the geographic wage gap in technology careers.\n\n![](Data/urban_vs_rural_ai_salaries.png)\n\n```{python}\n# Heatmap\nimport seaborn as sns \npivot = df.groupby(['STATE_NAME', 'Career_Type'])['SALARY'].median().unstack()\nplt.figure(figsize=(14, 6))\nsns.heatmap(pivot, annot=True, fmt=\".0f\", cmap=\"coolwarm\", linewidths=0.5)\nplt.title(\"Median Salary by State and Career Type\")\nplt.xlabel(\"Career Type\")\nplt.ylabel(\"State\")\nplt.tight_layout()\nplt.show()\n```\n\n```{python}\n# Group by state\nai_summary = df[df['Career_Type'] == 'AI Career'].groupby('STATE_NAME')['SALARY'].agg(\n    Median_Salary='median', Job_Count='count', Std_Dev='std').reset_index()\n\nplt.figure(figsize=(10, 6))\nplt.scatter(ai_summary['Median_Salary'], ai_summary['Job_Count'],\n            s=ai_summary['Job_Count'] / 1.5,\n            c=ai_summary['Std_Dev'], cmap='viridis', alpha=0.7, edgecolors='black')\n# Add state name labels to the bubbles\nfor i, row in ai_summary.iterrows():\n    if row['Job_Count'] > 300:  # Label only big bubbles to reduce clutter\n        plt.text(row['Median_Salary'], row['Job_Count'], row['STATE_NAME'],\n                 fontsize=8, ha='center', va='center', color='black')\n\nplt.colorbar(label='Salary Std Dev')\nplt.xlabel('Median Salary ($)')\nplt.ylabel('AI Job Count')\nplt.title('AI Career Opportunities: Salary vs Availability by State')\nplt.grid(True, linestyle='--', alpha=0.5)\nplt.tight_layout()\nplt.show()\n```\n\n```{python}\n# Reference lines\nmedian_salary_cutoff = ai_summary['Median_Salary'].median()\nmedian_job_count_cutoff = ai_summary['Job_Count'].median()\n\nplt.figure(figsize=(10, 6))\nplt.scatter(ai_summary['Median_Salary'], ai_summary['Job_Count'],\n            s=ai_summary['Job_Count'] / 1.5,\n            c=ai_summary['Std_Dev'], cmap='viridis', alpha=0.7, edgecolors='black')\n\n# Add quadrant lines\nplt.axvline(median_salary_cutoff, color='gray', linestyle='--', linewidth=1)\nplt.axhline(median_job_count_cutoff, color='gray', linestyle='--', linewidth=1)\n\n# Label top states\nfor i, row in ai_summary.iterrows():\n    if row['Job_Count'] > 300:\n        plt.text(row['Median_Salary'], row['Job_Count'], row['STATE_NAME'],\n                 fontsize=8, ha='center', va='center', color='black')\n\nplt.colorbar(label='Salary Std Dev')\nplt.xlabel('Median Salary ($)')\nplt.ylabel('AI Job Count')\nplt.title('AI Career Opportunities: Salary vs Availability (with Reference Lines)')\nplt.grid(True, linestyle='--', alpha=0.5)\nplt.tight_layout()\nplt.show()\n```\n\n### AI Salaries by State Heatmap\n\n```{python}\nimport plotly.express as px\n\n# Mapping of full state names to 2-letter codes\nstate_abbrev = {\n    'Alabama': 'AL', 'Alaska': 'AK', 'Arizona': 'AZ', 'Arkansas': 'AR', 'California': 'CA',\n    'Colorado': 'CO', 'Connecticut': 'CT', 'Delaware': 'DE', 'Florida': 'FL', 'Georgia': 'GA',\n    'Hawaii': 'HI', 'Idaho': 'ID', 'Illinois': 'IL', 'Indiana': 'IN', 'Iowa': 'IA',\n    'Kansas': 'KS', 'Kentucky': 'KY', 'Louisiana': 'LA', 'Maine': 'ME', 'Maryland': 'MD',\n    'Massachusetts': 'MA', 'Michigan': 'MI', 'Minnesota': 'MN', 'Mississippi': 'MS',\n    'Missouri': 'MO', 'Montana': 'MT', 'Nebraska': 'NE', 'Nevada': 'NV', 'New Hampshire': 'NH',\n    'New Jersey': 'NJ', 'New Mexico': 'NM', 'New York': 'NY', 'North Carolina': 'NC',\n    'North Dakota': 'ND', 'Ohio': 'OH', 'Oklahoma': 'OK', 'Oregon': 'OR', 'Pennsylvania': 'PA',\n    'Rhode Island': 'RI', 'South Carolina': 'SC', 'South Dakota': 'SD', 'Tennessee': 'TN',\n    'Texas': 'TX', 'Utah': 'UT', 'Vermont': 'VT', 'Virginia': 'VA', 'Washington': 'WA',\n    'West Virginia': 'WV', 'Wisconsin': 'WI', 'Wyoming': 'WY', 'District of Columbia': 'DC'\n}\n\n# Create dataframe with state abbreviations\nai_state_medians = df[df['Career_Type'] == 'AI Career'].groupby('STATE_NAME')['SALARY'].median().reset_index()\nai_state_medians['STATE_ABBR'] = ai_state_medians['STATE_NAME'].map(state_abbrev)\n\n# Now plot\nfig = px.choropleth(ai_state_medians,\n                    locations='STATE_ABBR',\n                    locationmode=\"USA-states\",\n                    color='SALARY',\n                    scope=\"usa\",\n                    color_continuous_scale=\"Viridis\",\n                    labels={'SALARY':'Median AI Salary'})\nfig.update_layout(title_text='Median AI Salary by State', geo=dict(showlakes=True))\nfig.show()\n\n```\n\n```{python}\nimport plotly.graph_objects as go\n\n# Prepare the base choropleth layer\nfig = go.Figure(data=go.Choropleth(\n    locations=ai_state_medians['STATE_ABBR'],  # 2-letter codes\n    z=ai_state_medians['SALARY'],\n    locationmode='USA-states',\n    colorscale='Viridis',\n    colorbar_title='Median AI Salary',\n    text=ai_state_medians['STATE_NAME'],  # hover text\n    hoverinfo='text+z'\n))\n\n# Add text annotations: state abbreviations\nfor i, row in ai_state_medians.iterrows():\n    fig.add_trace(go.Scattergeo(\n        locationmode='USA-states',\n        lon=[None],  # plotly doesn’t support precise state centroids natively\n        lat=[None],\n        text=row['STATE_ABBR'],\n        mode='text',\n        textfont=dict(color='white', size=10),\n        name=row['STATE_ABBR'],\n        showlegend=False\n    ))\n\n# Update map layout\nfig.update_layout(\n    title_text='Median AI Salary by State (with State Labels)',\n    geo=dict(\n        scope='usa',\n        showlakes=True,\n        lakecolor='rgb(255, 255, 255)'\n    )\n)\n\nfig.show()\n```\n\n#### Non AI Careers\n\n```{python}\nnonai_state_medians = df[df['Career_Type'] == 'Non-AI Career'].groupby('STATE_NAME')['SALARY'].median().reset_index()\nnonai_state_medians['STATE_ABBR'] = nonai_state_medians['STATE_NAME'].map(state_abbrev)\n```\n\n```{python}\nai_top = ai_state_medians[['STATE_NAME', 'SALARY']].rename(columns={'SALARY': 'AI_Median'})\nnonai_top = nonai_state_medians[['STATE_NAME', 'SALARY']].rename(columns={'SALARY': 'NonAI_Median'})\n\ncomparison = pd.merge(ai_top, nonai_top, on='STATE_NAME', how='inner')\ncomparison['Diff'] = comparison['AI_Median'] - comparison['NonAI_Median']\ncomparison.sort_values(by='Diff', ascending=False).head(10)\n```\n\n```{python}\n# Step 1: Get AI job counts per state\nai_counts = df[df['Career_Type'] == 'AI Career'].groupby('STATE_NAME')['SALARY'].count().reset_index(name='AI_Job_Count')\n\n# Step 2: Merge counts into comparison\ncomparison_with_counts = pd.merge(comparison, ai_counts, on='STATE_NAME', how='left')\n\n# Step 3: Filter for states with at least 100 AI jobs\nfiltered = comparison_with_counts[comparison_with_counts['AI_Job_Count'] >= 300]\n\n# Step 4: Take top 10 states by salary gap\ntop_realistic = filtered.sort_values(by='Diff', ascending=False).head(10).sort_values('AI_Median')\n\n# Step 5: Plot dumbbell chart\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(10, 6))\n\n# Draw connecting lines\nfor _, row in top_realistic.iterrows():\n    plt.plot([row['NonAI_Median'], row['AI_Median']], [row['STATE_NAME']] * 2, color='gray', linewidth=2)\n\n# Plot salary points\nplt.scatter(top_realistic['NonAI_Median'], top_realistic['STATE_NAME'], color='darkorange', label='Traditional Median Salary', s=80)\nplt.scatter(top_realistic['AI_Median'], top_realistic['STATE_NAME'], color='steelblue', label='AI Median Salary', s=80)\n\n# Annotate the difference\nfor _, row in top_realistic.iterrows():\n    plt.text(row['AI_Median'] + 1000, row['STATE_NAME'], f\"+${int(row['Diff']):,}\", fontsize=8, va='center', color='black')\n\nplt.xlabel(\"Median Salary ($)\")\nplt.title(\"AI vs Traditional Salaries (Top 10 States, ≥300 AI Jobs)\")\nplt.legend()\nplt.grid(axis='x', linestyle='--', alpha=0.5)\nplt.tight_layout()\nplt.show()\n```\n\n### Insight: Top States with Highest AI Salary Advantage (≥300 AI Jobs)\n\nThis chart compares the median salaries of AI-related and traditional careers in states with substantial AI job markets (300+ postings). Each line connects the traditional (orange) and AI (blue) median salaries for a given state, with the annotated value indicating the salary gap.\n\nKey takeaways:\n- **Michigan, California, and Florida** exhibit the most substantial salary premiums for AI roles, with gaps exceeding **$30,000–$50,000**.\n- **New Jersey, Georgia, and Illinois** also show consistent advantages, reinforcing the value of AI specialization in large-scale markets.\n- By filtering for states with significant job volume, we ensure these salary gaps are **statistically meaningful**, not outliers from niche postings.\n\nThis visualization reinforces that **AI careers aren't just higher paying — they're transformationally more lucrative** in regions where demand and infrastructure support sustainable opportunities.\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"css":["styles.css"],"output-file":"ai_vs_tradsalary_analysis.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.40","theme":"cosmo"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}