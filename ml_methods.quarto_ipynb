{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"ML Methods\"\n",
        "subtitle: \"Predicting Job Posting Duration Using Random Forest Regressor\"\n",
        "author:\n",
        "  - name: \"Shreya Mani\"\n",
        "    affiliations:\n",
        "          - id: bu\n",
        "            name: Boston University\n",
        "            city: Boston\n",
        "            state: MA\n",
        "format: \n",
        "  html:\n",
        "        toc: true\n",
        "        number-sections: true\n",
        "        df-print: paged\n",
        "---\n",
        "\n",
        "\n",
        "\n",
        "# Introduction\n",
        "\n",
        "In this machine learning project, I aimed to predict how long job postings remain active (i.e., their DURATION) using a Random Forest Regressor. The dataset contains job postings with features such as minimum years of experience, employment type, remote work status, internship status, and required education levels. My goal was to build a predictive model, evaluate its performance using the Mean Squared Error (MSE), and visualize the results with a scatter plot comparing actual and predicted durations. This analysis can help organizations understand factors influencing job posting durations, aiding in recruitment planning.\n",
        "\n",
        "# Data Preprocessing\n",
        "\n",
        "I started by loading the dataset and selecting a subset of features relevant to predicting DURATION. The features I chose were MIN_YEARS_EXPERIENCE, EMPLOYMENT_TYPE, REMOTE_TYPE, IS_INTERNSHIP, and EDUCATION_LEVELS, as they likely influence how long a job posting stays active. I handled missing values in the target variable (DURATION) by dropping rows with missing data.\n",
        "\n",
        "A challenge arose with the EDUCATION_LEVELS column, which contained string representations of lists . To address this, I wrote a preprocessing function to parse these strings, extract the first numerical value from each list, and convert it to an integer. This ensured that all features were numerical, as required by the Random Forest Regressor. The dataset was then split into training (80%) and testing (20%) sets to evaluate the model performance on unseen data.\n",
        "\n",
        "Here the Python code I used for data preprocessing:\n"
      ],
      "id": "7d5831e3"
    },
    {
      "cell_type": "code",
      "metadata": {
        "message": false
      },
      "source": [
        "#| label: ml data cleaning\n",
        "#| echo: true\n",
        "#| warning: false\n",
        "\n",
        "# Import necessary libraries\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "import os\n",
        "import ast\n",
        "from sklearn.impute import SimpleImputer\n",
        "from sklearn.model_selection import train_test_split\n",
        "\n",
        "# Set display options\n",
        "pd.set_option('display.max_columns', None)\n",
        "pd.set_option('display.max_rows', 100)\n",
        "\n",
        "# Auto-download CSV if missing\n",
        "csv_path = 'region_analysis/lightcast_job_postings.csv'\n",
        "if not os.path.exists(csv_path):\n",
        "    print(f\"{csv_path} not found! Attempting to download...\")\n",
        "    os.makedirs('region_analysis', exist_ok=True)\n",
        "    try:\n",
        "        import gdown\n",
        "    except ImportError:\n",
        "        print(\"Installing gdown...\")\n",
        "        !pip install gdown\n",
        "        import gdown\n",
        "    file_id = '1V2GCHGt2dkFGqVBeoUFckU4IhUgk4ocQ'  # Replace with actual file ID\n",
        "    url = f'https://drive.google.com/uc?id={file_id}'\n",
        "    try:\n",
        "        gdown.download(url, csv_path, quiet=False)\n",
        "        print(\"Download complete!\")\n",
        "    except Exception as e:\n",
        "        print(f\"Download failed: {e}\")\n",
        "        raise\n",
        "else:\n",
        "    print(f\"{csv_path} found. Proceeding...\")\n",
        "\n",
        "# Load the dataset\n",
        "try:\n",
        "    df = pd.read_csv(csv_path)\n",
        "    print(f\"Initial dataset size: {df.shape}\")\n",
        "    print(f\"Missing values:\\n{df[['DURATION', 'MIN_YEARS_EXPERIENCE', 'EMPLOYMENT_TYPE', 'REMOTE_TYPE', 'MIN_EDULEVELS']].isnull().sum()}\")\n",
        "except Exception as e:\n",
        "    print(f\"Error loading CSV: {e}\")\n",
        "    raise"
      ],
      "id": "ml-data-cleaning",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Sample of preprocessed EDUCATION_LEVELS\n"
      ],
      "id": "63d74d2c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Define function to parse MIN_EDULEVELS strings\n",
        "def parse_education_levels(edu):\n",
        "    if isinstance(edu, (int, float)) and not np.isnan(edu):\n",
        "        return int(edu)  # Return integer if already numerical\n",
        "    if isinstance(edu, str):\n",
        "        try:\n",
        "            edu_list = ast.literal_eval(edu.replace('\\n', ''))\n",
        "            return int(edu_list[0]) if isinstance(edu_list[0], (int, float)) else np.nan\n",
        "        except (ValueError, SyntaxError, IndexError) as e:\n",
        "            print(f\"Parsing failed for: {edu}, Error: {e}\")\n",
        "            return np.nan\n",
        "    return np.nan\n",
        "\n",
        "# Select features and target\n",
        "features = ['MIN_YEARS_EXPERIENCE', 'EMPLOYMENT_TYPE', 'REMOTE_TYPE', 'IS_INTERNSHIP', 'MIN_EDULEVELS']\n",
        "target = 'DURATION'\n",
        "\n",
        "# Check if all features and target exist\n",
        "missing_cols = [col for col in features + [target] if col not in df.columns]\n",
        "if missing_cols:\n",
        "    print(f\"Missing columns: {missing_cols}\")\n",
        "    # If IS_INTERNSHIP is missing, remove it from features\n",
        "    if 'IS_INTERNSHIP' in missing_cols:\n",
        "        features.remove('IS_INTERNSHIP')\n",
        "    else:\n",
        "        raise ValueError(\"Required columns not found in dataset\")\n",
        "\n",
        "# Create a copy of the dataset with selected columns\n",
        "df_subset = df[features + [target]].copy()\n",
        "\n",
        "# Parse MIN_EDULEVELS\n",
        "df_subset['MIN_EDULEVELS'] = df_subset['MIN_EDULEVELS'].apply(parse_education_levels)\n",
        "\n",
        "# Handle missing values with imputation for all numerical columns\n",
        "num_cols = [col for col in features if col in df_subset.columns]\n",
        "num_imputer = SimpleImputer(strategy='median')\n",
        "df_subset[num_cols] = num_imputer.fit_transform(df_subset[num_cols])\n",
        "\n",
        "# Impute DURATION with mean\n",
        "df_subset['DURATION'] = df_subset['DURATION'].fillna(df_subset['DURATION'].mean())\n",
        "\n",
        "# Ensure IS_INTERNSHIP is integer if present\n",
        "if 'IS_INTERNSHIP' in df_subset.columns:\n",
        "    df_subset['IS_INTERNSHIP'] = df_subset['IS_INTERNSHIP'].astype(int)\n",
        "\n",
        "# Verify no missing values\n",
        "print(f\"Missing values after imputation:\\n{df_subset.isnull().sum()}\")\n",
        "print(f\"Preprocessed dataset size: {df_subset.shape}\")\n",
        "\n",
        "# Features and target\n",
        "X = df_subset[num_cols]\n",
        "y = df_subset['DURATION']\n",
        "\n",
        "# Split the data into training and testing sets\n",
        "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n",
        "\n",
        "print(\"Training set size:\", X_train.shape)\n",
        "print(\"Testing set size:\", X_test.shape)\n",
        "print(\"Sample of preprocessed MIN_EDULEVELS:\", df_subset['MIN_EDULEVELS'].head().tolist())"
      ],
      "id": "af1a5d20",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Model Training\n",
        "\n",
        "With the data preprocessed, I trained a Random Forest Regressor, a robust model that handles numerical features well and is less prone to overfitting. The model was trained on the training set with 100 trees (n_estimators=100) to ensure stable predictions. Random Forest works by building multiple decision trees and averaging their predictions, which often leads to better performance compared to a single decision tree.\n",
        "\n",
        "Here is the code for training the Random Forest Regressor:\n"
      ],
      "id": "969f9b1c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from sklearn.ensemble import RandomForestRegressor\n",
        "\n",
        "# Initialize and train the Random Forest Regressor\n",
        "rf = RandomForestRegressor(n_estimators=100, random_state=42)\n",
        "rf.fit(X_train, y_train)\n",
        "\n",
        "print(\"Model training completed.\")"
      ],
      "id": "7b830f3b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Model Evaluation and Visualization\n",
        "After training the model, I used it to predict the DURATION for the test set. To evaluate the model performance, I calculated the Mean Squared Error (MSE), which measures the average squared difference between actual and predicted values. A lower MSE indicates better predictive accuracy.\n",
        "\n",
        "I also created a scatter plot to visualize the model performance, comparing the actual DURATION values to the predicted ones. A red dashed line represents perfect predictions (where actual equals predicted). Points closer to this line indicate better predictions.\n",
        "\n",
        "Here is the code for evaluation and visualization:\n"
      ],
      "id": "118d1cd2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from sklearn.metrics import mean_squared_error\n",
        "from sklearn.model_selection import cross_val_score\n",
        "\n",
        "# Cross-validation\n",
        "cv_scores = cross_val_score(rf, X, y, cv=5, scoring='neg_mean_squared_error')\n",
        "cv_mse = -cv_scores.mean()\n",
        "cv_rmse = np.sqrt(cv_mse)\n",
        "print(f\"Cross-validated MSE: {cv_mse:.2f} ± {cv_scores.std():.2f}\")\n",
        "print(f\"Cross-validated RMSE: {cv_rmse:.2f} days\")\n",
        "\n",
        "# Predict on test set\n",
        "y_pred = rf.predict(X_test)\n",
        "\n",
        "# Calculate MSE and RMSE on test set\n",
        "mse = mean_squared_error(y_test, y_pred)\n",
        "rmse = np.sqrt(mse)\n",
        "print(f\"Test set MSE: {mse:.2f}\")\n",
        "print(f\"Test set RMSE: {rmse:.2f} days\")\n",
        "\n",
        "# Feature importance\n",
        "feature_importance = pd.DataFrame({\n",
        "    'Feature': num_cols,\n",
        "    'Importance': rf.feature_importances_\n",
        "}).sort_values('Importance', ascending=False)\n",
        "print(\"\\nFeature Importance:\")\n",
        "print(feature_importance)\n",
        "\n",
        "# Plot actual vs predicted values\n",
        "plt.figure(figsize=(8, 6))\n",
        "plt.scatter(y_test, y_pred, color='blue', alpha=0.5, label='Predicted vs Actual')\n",
        "plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', label='Perfect Prediction')\n",
        "plt.xlabel('Actual Duration (Days)')\n",
        "plt.ylabel('Predicted Duration (Days)')\n",
        "plt.title('Random Forest Regressor: Actual vs Predicted Job Posting Duration')\n",
        "plt.legend()\n",
        "plt.grid(True)\n",
        "plt.savefig('actual_vs_predicted_duration.png')\n",
        "plt.show()"
      ],
      "id": "4436f98a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Results\n",
        "\n",
        "The Mean Squared Error (MSE) provides a quantitative measure of the model performance. In this case, the MSE reflects how well the model predicts job posting durations on the test set. The scatter plot (actual_vs_predicted_duration.png) visually demonstrates the model accuracy. With only a small dataset, the predictions may not be perfect, but the Random Forest Regressor captures general trends, as seen by the alignment of points near the perfect prediction line.\n",
        "\n",
        "# Conclusion\n",
        "\n",
        "Using a Random Forest Regressor, I built a model to predict the duration of job postings based on features like experience, employment type, and education level. The preprocessing step for EDUCATION_LEVELS was crucial to handle both string and float values, ensuring the data was in a numerical format suitable for the model. However, the model performance was poor, with an MSE of 1296.00 and a significant overprediction (42.0 days predicted vs. 6.0 days actual), as shown in the scatter plot. This analysis highlights the challenges of applying machine learning to very small datasets. Future improvements could involve collecting more data to increase the training set size, experimenting with feature engineering (e.g., one-hot encoding for EDUCATION_LEVELS if multiple values are meaningful), or trying simpler models like linear regression that may perform better with limited data."
      ],
      "id": "e12bcb71"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Library/Frameworks/Python.framework/Versions/3.13/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}